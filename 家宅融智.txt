家宅融智（北京）科技有限公司

基本介绍

公司福利：五险一金

企业类型：有限责任公司

所属行业：科技推广和应用服务业

总部地点：北京

创始人冯驌：“生活最大的快乐和意义就是,一直像现在这样痛快地做事情。”

企业地址：
    北京市朝阳区望京东园四区2号中航资本大厦9层901室

经营范围：
    技术推广、技术开发、技术咨询、技术服务、技术转让；数据处理；基础软件服务；应用软件服务（不含医用软件）；软件开发；组织文化艺术交流活动（不含演出）；会议及展览服务；销售日用品、家具（不从事实体店铺经营）、家用电器、灯具（不从事实体店铺经营）、装饰材料（不从事实体店铺经营）；设计、制作、代理、发布广告。（企业依法自主选择经营项目，开展经营活动；依法须经批准的项目，经相关部门批准后依批准的内容开展经营活动；不得从事本市产业政策禁止和限制类项目的经营活动。）


体现出自己的价值，项目管理，业务流程，功能开发，后期数据库优化（索引，分表，搭建主从）


    代码由小组交叉审核，使用git flow工作流
        1.1 master分支
            主分支，产品的功能全部实现后，最终在master分支对外发布。
        1.2 develop分支
            开发分支，基于master分支克隆，产品的编码工作在此分支进行。
        1.3 release分支
            测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。
        1.4 bugfix分支
            Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。
        1.5 feature分支
            功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。

业务：
    商品模块： 
        1.商品管理：
            商品的添加、修改、 删除、复制、批处理、商品计划上下架、SEO、商品多媒体上传等，可以定义商品是实体还是虚拟，可以定义是否预订、是否缺货销售等。 
        2.商品类型管理：
            定义商品的类型，设置自定义属性项、SKU项和商品评论项。  
        3.品牌管理：
            添加、修改、删除、上传品牌 LOGO。
        4.商品评论管理：
            回复、删除。
    系统模块： 
        1.安全管理：
            管理员、角色权限分配和安全日志 
        2.支付管理：
            支付方式、支付历史。
        3.数据导入管理：
            商品目录导入、商品导入、 会员资料导入。
    api接口：
        
优化：



每日推荐：Redis用字符串，



电子商务网站整个系统的后端管理，按功能划分为九大模块，包括商品组织管理、订单处理、内容发布管理等模块。

一、后台主页： 
  各类主要信息的概要统计，包括客户信息、 订单信息、商品信息、库存信息、评论和最近反馈等。 

二、商品模块： 

    1.商品管理：商品和商品包的添加、修改、 删除、复制、批处理、商品计划上下架、SEO、商品多媒体上传等，可以定义商品是实体还是虚拟，可以定义是否预订、是否缺货销售等。

    2.商品目录管理：树形的商品目录组织管理，并可以设置关联/商品推荐。   

    3.商品类型管理：定义商品的类型，设置自定义属性项、SKU项和商品评论项。  

    4.品牌管理：添加、修改、删除、上传品牌 LOGO。   

    5.商品评论管理：回复、删除。

三、销售模块： 
    1.促销管理：分为目录促销、购物车促销和 优惠券促销三类，可以随意定义不同的促销规则，满足日常促销活动：购物折扣、购物赠送积分、购物赠送优惠券、购物免运输费、特价商品、特定会员购买特定商品、折上折、买二送一等。   
      
    2.礼券管理：添加、发送礼券 

    3.关联/推荐管理――基于规则引擎，可以支持多种推荐类型，可手工添加或者自动评估商品。

四、订单模块： 

  1.订单管理：可以编辑、解锁、取消订单、 拆分订单、添加商品、移除商品、确认可备货等，也可对因促销规则发生变化引起的价格变化进行调整。订单处理完可发起退货、换货流程。 

  2.支付：常用于订单支付信息的查看和手工 支付两种功能。手工支付订单，常用于“款到发货”类型的订单，可理解为对款到发货这类订单的一种补登行为。 

  3.结算：提供商家与第三方物流公司的结算 功能，通常是月结。同时，结算功能也是常用来对“货到付款”这一类型订单支付后的数据进行对帐

五、库存模块： 

  1.库存管理：引入库存的概念，不包括销售 规则为永远可售的商品，一个SKU对应一个库存量。库存管理提供增加、减少等调整库存量的功能;另外，也可对具具体的SKU设置商品的保留数量、***小库存量、再进货数量。每条SKU商品的具体库存操作都会记录在库存明细记录里边。

  2.查看库存明细记录。 

  3.备货/发货：创建备货单、打印备货单、打印发货单、打印EMS快递单、完成发货等一系列物流配送的操作。 

  4.退/换货：对退/换货的订单进行收货流程的处理。

六、内容模块： 

    1.内容管理：包括内容管理以及内容目录管理。内容目录由树形结构组织管理。类似于商品目录的树形结构，可设置目录是否为链接目录。   

    2.无限制创建独立内容网页，比如关于我们，联系我们。 

    3.广告管理：添加、修改、删除、上传广告、 定义广告有效时限。 

    4.可自由设置商城导航栏目以及栏目内容、栏目链接。

七、客户模块： 

  1.客户管理：添加、删除、修改、重设密码、 发送邮件等。   

  2.反馈管理：删除、回复。 

  3.消息订阅管理：添加、删除、修改消息组 和消息、分配消息组、查看订阅人。   

  4.会员资格：添加、删除、修改。

八、系统模块： 

  1.安全管理：管理员、角色权限分配和安全日志 

  2.系统属性管理：用于管理自定义属性。可关联模块包括商品管理、商品目录管理、内容管理、客户管理。

  3.运输与区域：运输公司、运输方式、运输 地区。   

  4.支付管理：支付方式、支付历史。   

  5.包装管理：添加、修改、删除。 

  6.数据导入管理：商品目录导入、商品导入、 会员资料导入。   

  7.邮件队列管理：监控邮件发送情况，删除 发送异常邮件。

九、报表模块： 

  缺省数个统计报表，支持时间段过滤、支持按不同状态过滤、支持HTML、PDF和Excel格式的导出和打印。   
    1.用户注册统计   
    2.低库存汇总   
    3.缺货订单   
    4.订单汇总   
    5.退换货


git flow工作流：
    1.1 master分支
        主分支，产品的功能全部实现后，最终在master分支对外发布。
    1.2 develop分支
        开发分支，基于master分支克隆，产品的编码工作在此分支进行。
    1.3 release分支
        测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。
    1.4 bugfix分支
        Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。
    1.5 feature分支
        功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。


APP接口开发：
    协议：HTTPS协议；

api接口文档设计（ShowDoc）：
    错误码制定：
    协议：
用户验证方案：
    App操作中经常涉及用户登录操作，登录就需要使用到用户名和密码，为了安全起见，在登录过程中暴漏密码的次数越少越好。
    1.使用HTTPS协议
        HTTPS协议是 HTTP协议 和 SSL／TLS协议 的组合。其是一个安全通信通道，基于HTTP开发，用于在客户计算机和App后台之间交换信息。其使用安全套接字层（SSL）进行信息交换，简单来说就是HTTP的安全版。
        ☛避免信息的泄漏，最基本的方案是所有涉及安全性的API请求都必须使用HTTPS协议☚
    2.选择JSON作为数据交换格式
        JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，易于编写，也易于机器解析和生成，而且对比XML更省流量，这些特性使得JSON成为理想的数据交换语言。
    3.基本的用户验证方案
        传统Web网站使用Cookie+Session保持用户的登录状态，App后台则使用token进行验证，此时App已经获取到了token值，为了安全，我们不在网络上传输token，而使用签名校验（这里使用URL签名）的方式，API请求加上URL签名sign和用户id，这样，token就不需要附在URL上了。App后台签名校验，还有的童鞋喜欢设置时间戳，这样时间一长，URL就失效了，也是一种不错的进一步的优化方案。
        建议：为了保障数据安全，这里建议 同时使用 HTTPS 和 签名校验。
App后台架构的演进原则：
    App后台的架构是由业务规模驱动而演进的，App后台是为业务服务的，App后台的价值在于能为业务提供其所需要的功能，不应过度设计。
    从项目的角度，当App访问量不大时，应该快速搭建App后台，让App尽快上线给用户提供服务，验证商业模式的正确性，同时快速迭代产品。
    当App访问量不断上升，这时要在保证快速迭代的前提下，同时兼顾高性能和高可用。
    当App访问量达到一定阶段后，增长曲线就会放缓，但业务变得更加复杂，对高性能和高可用的要求也更高，性能问题、模块间的耦合、代码的复杂性会更加突出和明显，这时要使用业务拆分、分布式服务调用，甚至是技术转型等问题。
    1.项目启动时——单机部署
        我们看一个App后台极简化的架构：
        App后台极简化的架构
        一开始就使用Redis的好处：
        既能用作缓存，又能充当队列服务，而且并发性能高，能在长时间内应对业务压力，非常适合初期的项目。
        这里使用Redis验证用户信息，充当消息队列。
        而文件服务初期可以选择 文件云存储服务，或者自己搭建一个资源服务器。
    2.项目一定规模时——分布式部署
        我们看一个百万级到千万级的架构：
        百万级到千万级的架构
        这里新增了专门用于连接内部服务器的SSH服务的外网通道，保证SSH操作随时可用，同时加入了服务器集群，提供负载能力。
        随着业务的发展，某些数据表的规模会以几何级增长，当数据达到一定规模时，查询读取性能就下降的厉害，数据库主从的架构不能应对业务上的读写压力，这时架构上要考虑分表（水平拆分／垂直拆分）。
        当业务继续不断发展，数据库分表后的读写性能也可能没法满足业务上的需求，这时只能采用进一步的拆分策略——分库。用 Cobar 或者 MyCat 等关系型数据等分布式处理系统后，分库后的架构

数据库：
    数据表结构设计
    MySQL优化（索引，分表，SQL优化，）：
        MySQL Key值（PRI, UNI, MUL）的含义：PRI主键约束、UNI唯一约束、MUL可以重复。
        1.添加PRIMARY KEY（主键索引）
        mysql>ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )

        2.添加UNIQUE(唯一索引)
        mysql>ALTER TABLE `table_name` ADD UNIQUE (`column`)

        3.添加INDEX(普通索引)
        mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column` )

        4.添加FULLTEXT(全文索引)
        mysql>ALTER TABLE `table_name` ADD FULLTEXT (`column`)

        5.添加多列索引
        mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
    mysql连接池：
        大量应用中的重复模块会带来大量的访问，而每个应用与数据库的连接，一般是使用数据库的连接池，这个连接池的资源一般是不释放且一直保留着。假设连接池中有10个连接，中一个数百的服务器集群中，就占用了数据库1000个连接。数据库中的每个连接都是十分珍贵的资源，在资源有限的情况下，这里被占用了，其他能用的资源就少了。
    软件优化：
        1）正确使用MyISAM和InnoDB存储引擎
        2）正确使用索引
        3）避免使用 select *
        4）字段尽可能的设置 非NULL
    硬件优化：
        1）增加物理内存
        2）增加应用缓存
        3）使用SSD硬盘
    架构优化：
        1）分表
        2）读写分离
    读写分离架构
        3）分库（把一张表的数据分别存储在不同的数据库，可用MyCat实现，MyCat，关系型数据库分布式处理软件）。
        MyCat以代理服务器的形式位于App服务器和后台数据库之间，
        对外开放的接口是MySQL通信协议，将App服务器传过来的sql语句按照路由的规则拆解转发到不同的后台数据库，并把结果汇总返回。

选择合适的消息队列软件：
    1.当后台系统发现完成某些小任务需要花费很多时间，而且迟点晚成也不影响整个任务的完成进度时，就会把这些小任务交给消息队列。例如发送邮件、短信、推送消息等任务都非常适合在消息队列中处理。
    2.把这些任务放在消息队列中，可加快App后台请求都响应时间。同时消息队列也能把大量的并发请求变成串行的请求，来减轻服务器的负担。
常见的消息队列软件有：
    消息队列软件     ☆ 说明
    RabbitMQ        ☆ 重量级，适合企业级的开发，自带Web监控界面，方便监控队列的情况
    Redis           ☆ 轻量级，是一个key-value系统，但是也支持消息队列这种数据结构，App后台中Redis被广泛使用
    ZeroMQ          ☆ 号称最快，尤其针对大吞吐量的需求场景
    ActiveMQ        ☆ Apache的一个子项目，能够以代理人和点对点的技术实现队列
使用分布式服务实现业务的复用
    1.随着业务不断增加，后台系统由一个单一应用膨胀为一个巨无霸系统，系统中聚合了大量的应用和服务，各个模块之间有很多功能重复实现（例如登录模块），造成了开发、运维、部署的麻烦。
        膨胀的系统
    2.大量应用中的重复模块会带来大量的访问，而每个应用与数据库的连接，一般是使用数据库的连接池，这个连接池的资源一般是不释放且一直保留着。假设连接池中有10个连接，中一个数百的服务器集群中，就占用了数据库1000个连接。数据库中的每个连接都是十分珍贵的资源，在资源有限的情况下，这里被占用了，其他能用的资源就少了。

代码优化：
    1、规范代码，去除没有被用到的变量声明以及引用。像这种情况，eclipse配置好以后都会出现警告标志，会指明是“never used”。这种代码的问题很容易找到，也很容易修改，因此可以让自己感觉已经开始了优化工作，只要开始了，那么这个过程中就总能发现其他需要优化的地方。 
    2、规范代码，替换过时的和不推荐使用的方法。既然是过时和不被推荐的，自然有他的道理存在，除非是实在不知道怎么替换，否则我觉得都应该替换掉。这种情况和上面的情况稍有类似，也是eclipse编译的时候便会出现警告，很容易就识别出来，只不过改起来就要稍微复杂一些。 
    3、上边两个简单的优化搞定以后，我们就可以进行第三步了，注释优化。我个人认为，注释优化可以分成三种，一种是加和改，一种是减。
    说的具体明白点：
        1.加，就是对于那些负责具体功能和业务逻辑的类以及实体类的属性，如果没有注释我们应该加上注释，这样方便后续的维护，起码让人一眼就知道这个类、这个方法、这个属性是什么作用是什么意思。 
        2.改，就是对于明显不合理的注释进行修改，有的时候可能整个类被复制过来改个名字，这种情况就极有可能出现注释完全不搭调的情况；当然，也有可能是看起来注释了，实际上跟没注释没什么区别的注释。 
        3.减，就是对于那些被注释了的代码进行删除，当然了，这里我觉得也应该包括那些没有被删除的system.out.print。当然这种情况可能要根据实际情况，像我们这次遇到的完全是之前的人注释的，压根儿不知道干嘛的代码，多半是没人会再看的，我觉得就可以完全删除，省的占用空间还碍眼。 
    很显然，在这个过程中，删的时候相对简单，如果要加或者改，那么久需要了解相关的大概逻辑，也能进一步了解项目。
    4、这一步可能是在上一步之后，也可能就和上一步同时进行，因为很可能就是在上一步的过程中发现的问题，就是代码逻辑上的优化。
    5、经过上一步之后，整个代码的业务逻辑按理说我们应该已经了解的差不多了，也就不至于像一开始一样那么麻头了。而实际上这时候回头看看会发现，原来不知不觉中我们已经优化了很多东西了。那么这时候就可以进行一个对于性能来说至关重要的优化，但是相对来说也不太容易实施的步骤，那就是数据库优化。
        这里的数据库优化我觉得也可以分为两步：一个是sql语句的优化，一个就是表结构、索引相关的优化。
        sql语句的优化也有简单有难，比如我们这次，首先就发现有大量的sql语句使用了date_format、str_to_date、sysdate等函数，经测试发现这些函数是很影响性能的，而且完全可以不使用。
        除此之外，还可以根据实际情况组合sql语句中条件的顺序，有的时候也会有不一样的性能。
        而索引优化，这也需要结合业务逻辑，是大多数人一说到优化就先想到的东西，自然也是一个优化的方向。
        那么相对于上边两个，接下来的优化表结构就有可能比较伤筋动骨了，很可能把几个表整理成一个，也可能改动字段。
        这个时候不仅要动数据库，也要同时动sql和代码，工作量就比较大，但是却不可否认也是一个优化的方向，我们这次其中一个模块就把之前四五张表整合成了一个。
        那么还可能有一个问题，这个问题就不具备普遍性，那就是可能数据库中有完全无用的表。我们这一次经过整理后就发现，数据库中原来有41张表，结果我们只用到了19张，还有22张都不不知道干嘛的，最终被我们删掉。


技术分享会（不分领导，员工），
APP传输接口加密（HTTPS）：
    https=http+ssl，顾名思义，https是在http的基础上加上了SSL保护壳，信息的加密过程就是在SSL中完成的
对称加密特点是：
    私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。


嵌套技术：
    什么情况下，发生的什么问题，用的什么技术，达到什么效果。



企业站 -> OA -> APP 

极光推送，缓存（浏览器缓存、Nginx缓存、opcode缓存、Redis缓存【内存】、MySQL缓存、浏览器本地存储），

    关于缓存的两个概念（浏览器）
        强缓存：
            用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
        协商缓存：
            用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。
            两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。
            两者区别：从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互。
        1.浏览器缓存  
        一：静态资源的HTTP缓存

        1.浏览器对静态资源的HTTP缓存有两种情况，一种是强缓存(本地缓存)，另一种是弱缓存(协商缓存)。
        2.浏览器第一次请求资源时，必须下载所有的资源，然后根据响应的header内容来决定，如何缓存资源。可能采用的 是强缓存，也可能是弱缓存

        3.静态资源时的HTTP流程：
            1.强缓存阶段：先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器

            2.弱缓存阶段：在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。
            3.缓存失败阶段(重新请求)：当服务器发现该资源被修改过，或者在本地没有找到该缓存资源，服务器则返回该资源的数据。

        4.强缓存与弱缓存的区别：
            1.获取资源形式： 都是从缓存中获取资源的。

            2.状态码： 强缓存返回200(from cache),弱缓存返回304状态码

            3.请求(最大区别)：

                强缓存不发送请求，直接从缓存中取。
                弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）。
        5.强缓存：
            强缓存是利用Expires或者Cache-Control，让原始服务器为文件设置一个过期时间，在多长时间内可以将这些内容视为最新的。

            若时间未过期，则命中强缓存，使用缓存文件不发送请求。

        6.Cache-Control：
            Cache-Control是http1.1中为了弥补Expires的缺陷而加入的，当Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。

        7.http1.0时代的缓存 Expires+Pragma
            ★max-age=60：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 这里是60秒。
            1.Expires用于设置缓存到期时间：
                指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires，如果expires到期需要重新请求。

            ★no-cache:强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。http请求没有减少会减少一个响应体(文件内容),这种个选项类似弱缓存。
            2.Pragma禁用缓存：
                Pragma:no-cache 表示防止客户端缓存，需要强制从服务器获取最新的数据；

        8.强缓存命中 from memory cache & from disk cache：
            memory cache: 将资源存到内存中，从内存中获取。
            disk cache：将资源缓存到磁盘中，从磁盘中获取。

            二者最大的区别在于：当退出进程时，内存中的数据会被清空，而磁盘的数据不会。

        9.ETag是一个文件的唯一标志符。

        二：在Web应用领域，Web缓存大致可以分为以下几种类型：
            缓存分类：
                1.数据库数据缓存
                      Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。  
                2.服务器端缓存：
                    代理服务器缓存
                    CDN缓存
                3.浏览器端缓存
                        浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。
                4.Web应用层缓存
                        应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。
    MySQL缓存：
        命中条件
            缓存存在一个hash表中，通过查询SQL，查询数据库，客户端协议等作为key,在判断命中前，mysql不会解析SQL，而是使用SQL去查询缓存，SQL上的任何字符的不同，如空格，注释，都会导致缓存不命中。如果查询有不确定的数据like now(),current_date()，那么查询完成后结果者不会被缓存，包含不确定的数的是不会放置到缓存中。
        工作流程
            1.服务器接收SQL，以SQL和一些其他条件为key查找缓存表
            2.如果找到了缓存，则直接返回缓存
            3.如果没有找到缓存，则执行SQL查询，包括原来的SQL解析，优化等。
            4.执行完SQL查询结果以后，将SQL查询结果缓存入缓存表
        mysql缓存：一级缓存和二级缓存
            一级缓存：
            　　也称本地缓存，sqlSession级别的缓存。一级缓存是一直开启的；与数据库同一次回话期间查询到的数据会放在本地缓存中。
            　　如果需要获取相同的数据，直接从缓存中拿，不会再查数据库。
            一级缓存失效的四种情况：
                1.sqlSession不同。
                2.sqlSession相同，查询条件不同。因为缓存条件不同，缓存中还没有数据。
                3.sqlSession相同，在两次相同查询条件中间执行过增删改操作。（因为中间的增删改可能对缓存中数据进行修改，所以不能用）
                4.sqlSession相同，手动清空了一级缓存。
            二级缓存：全局缓存；基于namespace级别的缓存。一个namespace对应一个二级缓存。
                工作机制：
                    1.一个会话，查询一条数据，这个数据会被放在当前会话的一级缓存中。
                    2,如果会话被关闭了，一级缓存中的数据会被保存带二级缓存。新的会话查询信息就会参照二级缓存。
                    3.sqlSession ====> Employee====>employee
                      sqlSession ====>DepartmentMapper=====>Department
                      不同的namespace查出的数据会放在自己对应的缓存中。
                效果：查出的数据首先放在一级缓存中，只有一级缓存被关闭或者提交以后，一级缓存数据才会转移到二级缓存
                缓存首先一进来去查二级缓存，二级缓存没有去找一级缓存，一级缓存没有去找数据库。二级缓存----->一级缓存-------->数据库。
                自定义缓存 implements Cache,重写接口中的保存等方法，比如说保存到redis.
                自定义缓存参照mybatis官网--->项目git代码库----->https://github.com/mybatis---->参照各种整合缓存

        缓存失败
            当某个表正在写入数据，则这个表的缓存（命中缓存，缓存写入等）将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存。
        innodb_buffer_pool_size：
            缓存池的大小，这个很重要，在允许的范围内越大越好。
        innodb_buffer_pool_instances：
            缓冲池划分的区域默认是1，表示划分为一个区域。可以划分为多个区域，但是建议每个区域不小于1G的空间。
        排序缓存分为：普通排序缓存，MyISAM排序缓存以及InnoDB排序缓存。
        减少碎片策略：
            1.选择合适的block大小
            2.使用 FLUSH QUERY CACHE 命令整理碎片.这个命令在整理缓存期间,会导致其他连接无法使用查询缓存
            PS: 清空缓存的命令式 RESET QUERY CACHE 
        Mysql查询缓存碎片：
            1）当查询进行的时候，Mysql把查询结果保存在qurey cache中，但如果要保存的结果比较大，超过query_cache_min_res_unit的值 ，这时候mysql将一边检索结果，一边进行保存结果，所以，有时候并不是把所有结果全部得到后再进行一次性保存，而是每次分配一块 query_cache_min_res_unit 大小的内存空间保存结果集，使用完后，接着再分配一个这样的块，如果还不不够，接着再分配一个块，依此类推，也就是说，有可能在一次查询中，mysql要 进行多次内存分配的操作。
            2）内存碎片的产生。当一块分配的内存没有完全使用时，MySQL会把这块内存Trim掉，把没有使用的那部分归还以重 复利用。比如，第一次分配4KB,只用了3KB，剩1KB，第二次连续操作，分配4KB，用了2KB，剩2KB，这两次连续操作共剩下的 1KB+2KB=3KB，不足以做个一个内存单元分配， 这时候，内存碎片便产生了。
            3）使用flush query cache，可以消除碎片
            4）如果Qcache_free_blocks值过大，可能是query_cache_min_res_unit值过大，应该调小些
            5）query_cache_min_res_unit的估计值：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache
        InnoDB与查询缓存：
            Innodb会对每个表设置一个事务计数器,里面存储当前最大的事务ID.当一个事务提交时,InnoDB会使用MVCC中系统事务ID最大的事务ID跟新当前表的计数器.
            只有比这个最大ID大的事务能使用查询缓存,其他比这个ID小的事务则不能使用查询缓存.
            另外,在InnoDB中,所有有加锁操作的事务都不使用任何查询缓存
            查询必须是完全相同的(逐字节相同)才能够被认为是相同的。另外，同样的查询字符串由于其它原因可能认为是不同的。使用不同的数据库、不同的协议版本或者不同 默认字符集的查询被认为是不同的查询并且分别进行缓存。

        Mysql中MVCC的使用及原理详解
            测试环境：Mysql 5.7.20-log
            数据库默认隔离级别：RR（Repeatable Read，可重复读），MVCC主要适用于Mysql的RC,RR隔离级别
            特点：
                1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广
                2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.
                基本原理
                MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

        Redis缓存：



运维，这里指互联网运维，通常属于技术部门，与研发、测试、系统管理同为互联网产品技术支撑的4大部门，这个划分在国内和国外以及大小公司间都会多少有一些不同。
一个互联网产品的生成一般经历的过程是：产品经理、需求分析、研发部门开发、测试部门测试、运维部门部署发布以及长期的运行维护。

数据库范式：
    第一范式：确保每一列的原子性
    第二范式：非键字段必须依赖于键字段
    第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性

职场面试介绍：
    https://blog.csdn.net/zhuguanghalo/article/details/86496138


我的未来5年的规划是：因为我本人是学计算机的，所以希望沿着以技术为主线的路走下去。5年以后，我希望自己能够对某一个领域有比较深入的理解，成为某一领域的专家，在某一方面能独挡一面，同时也能够了解其他领域的发展动态


阻塞模式：(如果其他进程已经加锁文件,当前进程会一直等其他进程解锁文件后继续执行)

<?php
    //连接数据库
    $con=mysqli_connect("192.168.2.186","root","root","test");
     
    //查询商品数量是否大于0,大于0才能下单,并减少库存
     
    $fp = fopen("lock.txt", "r");
    //加锁
    if(flock($fp,LOCK_EX))
    {
        $res=mysqli_fetch_assoc(mysqli_query($con,'SELECT total FROM shop WHERE id=1 LIMIT 1'));
        if($res['total']>0){mysqli_query($con,'UPDATE shop SET total=total-1  WHERE id=1');}
        //执行完成解锁
        flock($fp,LOCK_UN);
    }
    //关闭文件
    fclose($fp);
    unset($res);
    mysqli_close($con);
?>

非阻塞模式：(如果其他进程已经加锁文件,当前进程不会等其他进程解锁文件,直接返回,也就是直接忽略加锁的代码到关闭文件那块)

<?php
    //连接数据库
    $con=mysqli_connect("192.168.2.186","root","root","test");
     
    //查询商品数量是否大于0,大于0才能下单,并减少库存
     
    $fp = fopen("lock.txt", "r");
    //加锁
    if(flock($fp,LOCK_EX | LOCK_NB))
    {
        $res=mysqli_fetch_assoc(mysqli_query($con,'SELECT total FROM shop WHERE id=1 LIMIT 1'));
        if($res['total']>0){mysqli_query($con,'UPDATE shop SET total=total-1  WHERE id=1');}
        //执行完成解锁
        flock($fp,LOCK_UN);
    }
    //关闭文件
    fclose($fp);
    unset($res);
    mysqli_close($con);
?>


索引结构：
    


