  MySQL缓存：
        命中条件
            缓存存在一个hash表中，通过查询SQL，查询数据库，客户端协议等作为key,在判断命中前，mysql不会解析SQL，而是使用SQL去查询缓存，SQL上的任何字符的不同，如空格，注释，都会导致缓存不命中。如果查询有不确定的数据like now(),current_date()，那么查询完成后结果者不会被缓存，包含不确定的数的是不会放置到缓存中。
        工作流程
            1.服务器接收SQL，以SQL和一些其他条件为key查找缓存表
            2.如果找到了缓存，则直接返回缓存
            3.如果没有找到缓存，则执行SQL查询，包括原来的SQL解析，优化等。
            4.执行完SQL查询结果以后，将SQL查询结果缓存入缓存表
        mysql缓存：一级缓存和二级缓存
            一级缓存：
            　　也称本地缓存，sqlSession级别的缓存。一级缓存是一直开启的；与数据库同一次回话期间查询到的数据会放在本地缓存中。
            　　如果需要获取相同的数据，直接从缓存中拿，不会再查数据库。
            一级缓存失效的四种情况：
                1.sqlSession不同。
                2.sqlSession相同，查询条件不同。因为缓存条件不同，缓存中还没有数据。
                3.sqlSession相同，在两次相同查询条件中间执行过增删改操作。（因为中间的增删改可能对缓存中数据进行修改，所以不能用）
                4.sqlSession相同，手动清空了一级缓存。
            二级缓存：全局缓存；基于namespace级别的缓存。一个namespace对应一个二级缓存。
                工作机制：
                    1.一个会话，查询一条数据，这个数据会被放在当前会话的一级缓存中。
                    2,如果会话被关闭了，一级缓存中的数据会被保存带二级缓存。新的会话查询信息就会参照二级缓存。
                    3.sqlSession ====> Employee====>employee
                      sqlSession ====>DepartmentMapper=====>Department
                      不同的namespace查出的数据会放在自己对应的缓存中。
                效果：查出的数据首先放在一级缓存中，只有一级缓存被关闭或者提交以后，一级缓存数据才会转移到二级缓存
                缓存首先一进来去查二级缓存，二级缓存没有去找一级缓存，一级缓存没有去找数据库。二级缓存----->一级缓存-------->数据库。
                自定义缓存 implements Cache,重写接口中的保存等方法，比如说保存到redis.
                自定义缓存参照mybatis官网--->项目git代码库----->https://github.com/mybatis---->参照各种整合缓存

        缓存失败
            当某个表正在写入数据，则这个表的缓存（命中缓存，缓存写入等）将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存。
        innodb_buffer_pool_size：
            缓存池的大小，这个很重要，在允许的范围内越大越好。
        innodb_buffer_pool_instances：
            缓冲池划分的区域默认是1，表示划分为一个区域。可以划分为多个区域，但是建议每个区域不小于1G的空间。
        排序缓存分为：普通排序缓存，MyISAM排序缓存以及InnoDB排序缓存。
        减少碎片策略：
            1.选择合适的block大小
            2.使用 FLUSH QUERY CACHE 命令整理碎片.这个命令在整理缓存期间,会导致其他连接无法使用查询缓存
            PS: 清空缓存的命令式 RESET QUERY CACHE 
        Mysql查询缓存碎片：
            1）当查询进行的时候，Mysql把查询结果保存在qurey cache中，但如果要保存的结果比较大，超过query_cache_min_res_unit的值 ，这时候mysql将一边检索结果，一边进行保存结果，所以，有时候并不是把所有结果全部得到后再进行一次性保存，而是每次分配一块 query_cache_min_res_unit 大小的内存空间保存结果集，使用完后，接着再分配一个这样的块，如果还不不够，接着再分配一个块，依此类推，也就是说，有可能在一次查询中，mysql要 进行多次内存分配的操作。
            2）内存碎片的产生。当一块分配的内存没有完全使用时，MySQL会把这块内存Trim掉，把没有使用的那部分归还以重 复利用。比如，第一次分配4KB,只用了3KB，剩1KB，第二次连续操作，分配4KB，用了2KB，剩2KB，这两次连续操作共剩下的 1KB+2KB=3KB，不足以做个一个内存单元分配， 这时候，内存碎片便产生了。
            3）使用flush query cache，可以消除碎片
            4）如果Qcache_free_blocks值过大，可能是query_cache_min_res_unit值过大，应该调小些
            5）query_cache_min_res_unit的估计值：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache
        InnoDB与查询缓存：
            Innodb会对每个表设置一个事务计数器,里面存储当前最大的事务ID.当一个事务提交时,InnoDB会使用MVCC中系统事务ID最大的事务ID跟新当前表的计数器.
            只有比这个最大ID大的事务能使用查询缓存,其他比这个ID小的事务则不能使用查询缓存.
            另外,在InnoDB中,所有有加锁操作的事务都不使用任何查询缓存
            查询必须是完全相同的(逐字节相同)才能够被认为是相同的。另外，同样的查询字符串由于其它原因可能认为是不同的。使用不同的数据库、不同的协议版本或者不同 默认字符集的查询被认为是不同的查询并且分别进行缓存。

        Mysql中MVCC的使用及原理详解
            测试环境：Mysql 5.7.20-log
            数据库默认隔离级别：RR（Repeatable Read，可重复读），MVCC主要适用于Mysql的RC,RR隔离级别
            特点：
                1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广
                2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.
                基本原理
                MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。
