<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>程旭辕Personal summary</title>
    <style type="text/css">
        html,body{
            width:100%;
            height:100%
        }

        body{
             background: url(./素材背景图.jpg) no-repeat top left;
            background-size: cover;
        }

        div {
            width: 82%;
            margin:0 auto;
            /*background-color: #C1FFC1;*/
            /*background-image: url(https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=234634259,4236876085&fm=27&gp=0.jpg);*/
            overflow:scroll;
            height:85%;
            margin-top: 6%;
        }

        h1 {
            text-align: center;
            color: red;
        }

        p {
            font-size: 25px;
            color: #B452CD;
        }

        span {
            font-size: 23px;
            color:blue;
            margin-left: 45px;
        }

        img {
            width: 100%;
        }

        hr {
            width: 100%;
            height: 5px;
            background-color: red;
        }
    </style>
</head>
<body>

    <div>
        <h1>Personal summary</h1>
        <p>网络攻击分类（五类）</p>
        <p>一:被动攻击</p>
        <span>被动攻击是对信息的保密性进行攻击，窃取信息的来源以及数据，对信息加以查看。主要的攻击方式有窃听，嗅探等。对被动攻击采取的防范措施应该是阻止而不是检测。比如进行数据加密。</span>
        <p>二：主动攻击</p>
        <span>主动攻击是指攻击信息来源的真实性，数据传输的完整性以及系统服务的可用性。对截取的信息进行修改，添加或删除等操作。主要的攻击方式有欺骗，重放，假冒，拒绝服务和消息篡改等方式，对主动攻击采取的防范措施为数据检测,防火墙等。</span>
        <p>三：内部人员攻击</p>
        <span>内部人员攻击指有的人授权在信息安全处理系统物理范围内或有直接访问内部安全信息处理系统的权限，可进行攻击</span>
        <p>四：物理临近攻击</p>
        <span>指未授权者在物理上临近网络,系统或设备，目的为修改，收集信息或拒绝为用户服务</span>
        <p>五：分布攻击</p>
        <span>指在硬件或软件在开发出来以后和被安装之前，或当其从一个地方转移到另一个地方之前，可进行攻击（修改软硬件）</span>
        <hr>
        <p>类 extends</p>
        <span>在PHP中，子类extends父类，当子类和父类里的方法同时存在，会优先执行本类里的方法</span>
        <hr>
        <p>获取当天的开始时间及结束时间</p>
        <span>$beginToday=mktime(0,0,0,date('m'),date('d'),date('Y'));</span><br>
        <span>$endToday=mktime(0,0,0,date('m'),date('d')+1,date('Y'))-1;</span>
        <p>获取昨天的开始时间及结束时间</p>
        <span>$beginYesterday=mktime(0,0,0,date('m'),date('d')-1,date('Y'));</span><br>
        <span>$endYesterday=mktime(0,0,0,date('m'),date('d'),date('Y'))-1;</span>
        <p>获取近七天的时间戳</p>
        <span>$sevenDays = strtotime('-7 days');</span><br>
        <span>$now = time();</span>
        <p>获取本月的开始时间及结束时间</p>
        <span>$beginThismonth=mktime(0,0,0,date('m'),1,date('Y'));</span><br>
        <span>$endThismonth=mktime(23,59,59,date('m'),date('t'),date('Y'));</span>
        <p>获取上个月的开始时间及结束时间</p>
        <span>$begin_time = strtotime(date('Y-m-01 00:00:00',strtotime('-1 month')));</span><br>
        <span>$end_time =  strtotime(date("Y-m-d 23:59:59", strtotime(-date('d').'day')));</span>
        <hr>

        <!-- 电商后台功能模块 -->
        <h1>电商网站后台九大功能模块详解 </h1>
        <p>随着电子商务的发展，网上购物正在趋于一种时尚，电子商务网站也逐渐成为企业顺应潮流的标配。大多数人知道可能在电子商务网站前端有查询，注册登录，购物车等等功能。可是您知道建设电子商务网站后台功能模块都有哪些么?今天我们就聊聊电商网站后台功能模块的那些事。</p>
        <P>电子商务网站整个系统的后端管理，按功能划分为九大模块，包括商品组织管理、订单处理、内容发布管理等模块。</P>
        <P>一、后台主页：</P>
        <span>各类主要信息的概要统计，包括客户信息、 订单信息、商品信息、库存信息、评论和最近反馈等。 </span>
        <p>二、商品模块：</p>
        <span>1.商品管理：商品和商品包的添加、修改、 删除、复制、批处理、商品计划上下架、SEO、商品多媒体上传等，可以定义商品是实体还是虚拟，可以定义是否预订、是否缺货销售等。</span><br>
        <span>2.商品目录管理：树形的商品目录组织管理，并可以设置关联/商品推荐。 </span><br>
        <span>3.商品类型管理：定义商品的类型，设置自定义属性项、SKU项和商品评论项。 </span><br>
        <span>4.品牌管理：添加、修改、删除、上传品牌 LOGO。</span><br>
        <span>5.商品评论管理：回复、删除。</span>
        <p>三、销售模块： </p>
        <span>1.促销管理：分为目录促销、购物车促销和 优惠券促销三类，可以随意定义不同的促销规则，满足日常促销活动：购物折扣、购物赠送积分、购物赠送优惠券、购物免运输费、特价商品、特定会员购买特定商品、折上折、买二送一等。</span><br>
        <span>2.礼券管理：添加、发送礼券</span><br>
        <span>3.关联/推荐管理――基于规则引擎，可以支持多种推荐类型，可手工添加或者自动评估商品。</span>
        <p>四、订单模块：</p>
        <span>1.订单管理：可以编辑、解锁、取消订单、 拆分订单、添加商品、移除商品、确认可备货等，也可对因促销规则发生变化引起的价格变化进行调整。订单处理完可发起退货、换货流程。</span><br>
        <span>2.支付：常用于订单支付信息的查看和手工 支付两种功能。手工支付订单，常用于“款到发货”类型的订单，可理解为对款到发货这类订单的一种补登行为。</span><br>
        <span>3.结算：提供商家与第三方物流公司的结算 功能，通常是月结。同时，结算功能也是常用来对“货到付款”这一类型订单支付后的数据进行对帐</span>
        <p>五、库存模块：</p>
        <span>1.库存管理：引入库存的概念，不包括销售 规则为永远可售的商品，一个SKU对应一个库存量。库存管理提供增加、减少等调整库存量的功能;另外，也可对具具体的SKU设置商品的保留数量、***小库存量、再进货数量。每条SKU商品的具体库存操作都会记录在库存明细记录里边。</span><br>
        <span>2.查看库存明细记录。</span><br>
        <span>3.备货/发货：创建备货单、打印备货单、打印发货单、打印EMS快递单、完成发货等一系列物流配送的操作。</span><br>
        <span>4.退/换货：对退/换货的订单进行收货流程的处理。</span>
        <p>六、内容模块：</p>
        <span>1.内容管理：包括内容管理以及内容目录管理。内容目录由树形结构组织管理。类似于商品目录的树形结构，可设置目录是否为链接目录。</span><br>
        <span>2.无限制创建独立内容网页，比如关于我们，联系我们。 </span><br>
        <span>3.广告管理：添加、修改、删除、上传广告、 定义广告有效时限。</span><br>
        <span>4.可自由设置商城导航栏目以及栏目内容、栏目链接。</span>
        <p>七、客户模块：</p>
        <span>1.客户管理：添加、删除、修改、重设密码、 发送邮件等。</span><br>
        <span>2.反馈管理：删除、回复。 </span><br>
        <span>3.消息订阅管理：添加、删除、修改消息组 和消息、分配消息组、查看订阅人。</span><br>
        <span>4.会员资格：添加、删除、修改。</span>
        <p>八、系统模块：</p>
        <span>1.安全管理：管理员、角色权限分配和安全日志</span><br>
        <span>2.系统属性管理：用于管理自定义属性。可关联模块包括商品管理、商品目录管理、内容管理、客户管理。</span><br>
        <span>3.运输与区域：运输公司、运输方式、运输 地区。</span><br>
        <span>4.支付管理：支付方式、支付历史。</span><br>
        <span>5.包装管理：添加、修改、删除。</span><br>
        <span>6.数据导入管理：商品目录导入、商品导入、 会员资料导入。 </span><br>
        <span>7.邮件队列管理：监控邮件发送情况，删除 发送异常邮件。</span>
        <p>九、报表模块：</p>
        <span>缺省数个统计报表，支持时间段过滤、支持按不同状态过滤、支持HTML、PDF和Excel格式的导出和打印。 </span><br>
        <span>1.用户注册统计 </span><br>
        <span>2.低库存汇总</span><br>
        <span>3.缺货订单 </span><br>
        <span>4.订单汇总 </span><br>
        <span>5.退换货</span>
        <hr>

        <!-- 数据库 -->
        <h1>MySQL数据库</h1>
        <p>主从复制</p>
        <p>1.MySQL 主从复制概念：</p>
        <span>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</span>
        <p>2.MySQL 主从复制主要用途：</p>
        <span>读写分离，在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</span>
        <p>3.架构扩展</p>
        <span>随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。</span>
        <p>4.MySQL 主从复制原理</p>
        <span>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点；</span>
        <p>总结：</p>
        <span>Mysql 主从复制是mysql 高可用，高性能的基础，有了这个基础，mysql 的部署会变得简单、灵活并且具有多样性，从而可以根据不同的业务场景做出灵活的调整。</span>
        <hr>
        <p>数据表结构设计</p>
        <p>MySQL优化（索引，分表，SQL优化，）：</p>
        <span>MySQL Key值（PRI, UNI, MUL）的含义：PRI主键约束、UNI唯一约束、MUL可以重复。</span>
        <p>1.添加PRIMARY KEY（主键索引）</p>
        <span>mysql>ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )</span>
        <p>2.添加UNIQUE(唯一索引)</p>
        <span>mysql>ALTER TABLE `table_name` ADD UNIQUE (`column`)</span>
        <p>3.添加INDEX(普通索引)</p>
        <span>mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column` )</span>
        <p>4.添加FULLTEXT(全文索引)</p>
        <span>mysql>ALTER TABLE `table_name` ADD FULLTEXT (`column`)</span>
        <p>5.添加多列索引</p>
        <span>mysql>ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )</span>
        <hr>
        <p>mysql连接池：</p>
        <span>大量应用中的重复模块会带来大量的访问，而每个应用与数据库的连接，一般是使用数据库的连接池，这个连接池的资源一般是不释放且一直保留着。假设连接池中有10个连接，中一个数百的服务器集群中，就占用了数据库1000个连接。数据库中的每个连接都是十分珍贵的资源，在资源有限的情况下，这里被占用了，其他能用的资源就少了。</span>
        <p>软件优化：</p>
        <span>1）正确使用MyISAM和InnoDB存储引擎</span><br>
        <span>2）正确使用索引</span><br>
        <span>3）避免使用 select *</span><br>
        <span>4）字段尽可能的设置 非NULL</span><br>
        <p>硬件优化：</p>
        <span>1）增加物理内存</span><br>
        <span>2）增加应用缓存</span><br>
        <span>3）使用SSD硬盘</span><br>
        <p>架构优化：</p>
        <span>1）分表</span><br>
        <span>2）读写分离</span><br>
        <span>3）分库（把一张表的数据分别存储在不同的数据库，可用MyCat实现，MyCat，关系型数据库分布式处理软件）。MyCat以代理服务器的形式位于App服务器和后台数据库之间，对外开放的接口是MySQL通信协议，将App服务器传过来的sql语句按照路由的规则拆解转发到不同的后台数据库，并把结果汇总返回。</span>
        <hr>
        <p>选择合适的消息队列软件：</p>
        <span>1.当后台系统发现完成某些小任务需要花费很多时间，而且迟点晚成也不影响整个任务的完成进度时，就会把这些小任务交给消息队列。例如发送邮件、短信、推送消息等任务都非常适合在消息队列中处理。</span><br>
        <span>2.把这些任务放在消息队列中，可加快App后台请求都响应时间。同时消息队列也能把大量的并发请求变成串行的请求，来减轻服务器的负担。常见的消息队列软件有：</span><br>
        <span><span>消息队列软件     ☆ 说明</span></span><br>
        <span><span>RabbitMQ        ☆ 重量级，适合企业级的开发，自带Web监控界面，方便监控队列的情况</span></span><br>
        <span><span>Redis           ☆ 轻量级，是一个key-value系统，但是也支持消息队列这种数据结构，App后台中Redis被广泛使用</span></span><br>
        <span><span>ZeroMQ          ☆ 号称最快，尤其针对大吞吐量的需求场景</span></span><br>
        <span><span>ActiveMQ        ☆ Apache的一个子项目，能够以代理人和点对点的技术实现队列</span></span><br>
        <p>使用分布式服务实现业务的复用</p>
        <span>1.随着业务不断增加，后台系统由一个单一应用膨胀为一个巨无霸系统，系统中聚合了大量的应用和服务，各个模块之间有很多功能重复实现（例如登录模块），造成了开发、运维、部署的麻烦。</span><br>
        <span>2.大量应用中的重复模块会带来大量的访问，而每个应用与数据库的连接，一般是使用数据库的连接池，这个连接池的资源一般是不释放且一直保留着。假设连接池中有10个连接，中一个数百的服务器集群中，就占用了数据库1000个连接。数据库中的每个连接都是十分珍贵的资源，在资源有限的情况下，这里被占用了，其他能用的资源就少了。</span>
        <hr>

        <!-- MySQL缓存 -->
        <h1>MySQL缓存</h1>
        <p>命中条件</p>
        <span>缓存存在一个hash表中，通过查询SQL，查询数据库，客户端协议等作为key,在判断命中前，mysql不会解析SQL，而是使用SQL去查询缓存，SQL上的任何字符的不同，如空格，注释，都会导致缓存不命中。如果查询有不确定的数据like now(),current_date()，那么查询完成后结果者不会被缓存，包含不确定的数的是不会放置到缓存中。</span>
        <p>工作流程</p>
        <span>1.服务器接收SQL，以SQL和一些其他条件为key查找缓存表</span><br>
        <span>2.如果找到了缓存，则直接返回缓存</span><br>
        <span>3.如果没有找到缓存，则执行SQL查询，包括原来的SQL解析，优化等。</span><br>
        <span>4.执行完SQL查询结果以后，将SQL查询结果缓存入缓存表</span><br>
        <p>mysql缓存：一级缓存和二级缓存</p>
        <p>一级缓存：</p>
        <span>也称本地缓存，sqlSession级别的缓存。一级缓存是一直开启的；与数据库同一次回话期间查询到的数据会放在本地缓存中。</span><br>
        <span>如果需要获取相同的数据，直接从缓存中拿，不会再查数据库。</span><br>
        <span><p>一级缓存失效的四种情况：</p></span><br>
        <span><span>1.sqlSession不同。</span></span><br>
        <span><span>2.sqlSession相同，查询条件不同。因为缓存条件不同，缓存中还没有数据。</span></span><br>
        <span><span>3.sqlSession相同，在两次相同查询条件中间执行过增删改操作。（因为中间的增删改可能对缓存中数据进行修改，所以不能用）</span></span><br>
        <span><span>4.sqlSession相同，手动清空了一级缓存。</span></span><br>
        <p>二级缓存：</p>
        <span>全局缓存；基于namespace级别的缓存。一个namespace对应一个二级缓存。</span><br>
        <span>工作机制：</span><br>
        <span><span>1.一个会话，查询一条数据，这个数据会被放在当前会话的一级缓存中。</span></span><br>
        <span><span>2,如果会话被关闭了，一级缓存中的数据会被保存带二级缓存。新的会话查询信息就会参照二级缓存。</span></span><br>
        <span><span>3.sqlSession ====> Employee====>employee</span></span><br>
        <span><span>sqlSession ====> DepartmentMapper=====>Department</span></span><br>
        <span><span>不同的namespace查出的数据会放在自己对应的缓存中。</span></span><br>
        <span>效果：查出的数据首先放在一级缓存中，只有一级缓存被关闭或者提交以后，一级缓存数据才会转移到二级缓存</span><br>
        <span>缓存首先一进来去查二级缓存，二级缓存没有去找一级缓存，一级缓存没有去找数据库。二级缓存----->一级缓存-------->数据库。</span><br>
        <span>自定义缓存 implements Cache,重写接口中的保存等方法，比如说保存到redis.</span><br>
        <span>自定义缓存参照mybatis官网--->项目git代码库----->https://github.com/mybatis---->参照各种整合缓存</span><br>
        <span></span><br>
        <p>缓存失败</p>
        <span>当某个表正在写入数据，则这个表的缓存（命中缓存，缓存写入等）将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存。</span>
        <p>innodb_buffer_pool_size：</p>
        <span>缓存池的大小，这个很重要，在允许的范围内越大越好。</span>
        <p>innodb_buffer_pool_instances：</p>
        <span>缓冲池划分的区域默认是1，表示划分为一个区域。可以划分为多个区域，但是建议每个区域不小于1G的空间。</span>
        <p>排序缓存分为：</p>
        <span>普通排序缓存</span><br>
        <span>MyISAM排序缓存以及InnoDB排序缓存</span><br>
        <p>减少碎片策略：</p>
        <span>1.选择合适的block大小</span><br>
        <span>2.使用 FLUSH QUERY CACHE 命令整理碎片.这个命令在整理缓存期间,会导致其他连接无法使用查询缓存</span><br>
        <span>PS: 清空缓存的命令式 RESET QUERY CACHE </span><br>
        <p>Mysql查询缓存碎片：</p>
        <span>1）当查询进行的时候，Mysql把查询结果保存在qurey cache中，但如果要保存的结果比较大，超过query_cache_min_res_unit的值 ，这时候mysql将一边检索结果，一边进行保存结果，所以，有时候并不是把所有结果全部得到后再进行一次性保存，而是每次分配一块 query_cache_min_res_unit 大小的内存空间保存结果集，使用完后，接着再分配一个这样的块，如果还不不够，接着再分配一个块，依此类推，也就是说，有可能在一次查询中，mysql要 进行多次内存分配的操作。</span><br>
        <span>2）内存碎片的产生。当一块分配的内存没有完全使用时，MySQL会把这块内存Trim掉，把没有使用的那部分归还以重 复利用。比如，第一次分配4KB,只用了3KB，剩1KB，第二次连续操作，分配4KB，用了2KB，剩2KB，这两次连续操作共剩下的 1KB+2KB=3KB，不足以做个一个内存单元分配， 这时候，内存碎片便产生了。</span><br>
        <span>3）使用flush query cache，可以消除碎片</span><br>
        <span>4）如果Qcache_free_blocks值过大，可能是query_cache_min_res_unit值过大，应该调小些</span><br>
        <span>5）query_cache_min_res_unit的估计值：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache
        InnoDB与查询缓存：</span><br>
        <span><span>Innodb会对每个表设置一个事务计数器,里面存储当前最大的事务ID.当一个事务提交时,InnoDB会使用MVCC中系统事务ID最大的事务ID跟新当前表的计数器.</span></span><br>
        <span><span>只有比这个最大ID大的事务能使用查询缓存,其他比这个ID小的事务则不能使用查询缓存.</span></span><br>
        <span><span>另外,在InnoDB中,所有有加锁操作的事务都不使用任何查询缓存</span></span><br>
        <span><span>查询必须是完全相同的(逐字节相同)才能够被认为是相同的。另外，同样的查询字符串由于其它原因可能认为是不同的。使用不同的数据库、不同的协议版本或者不同 默认字符集的查询被认为是不同的查询并且分别进行缓存。</span></span><br>
        <p>Mysql中MVCC的使用及原理详解</p>
        <span>测试环境：Mysql 5.7.20-log</span><br>
        <span>数据库默认隔离级别：RR（Repeatable Read，可重复读），MVCC主要适用于Mysql的RC,RR隔离级别</span><br>
        <span>特点：</span><br>
        <span><span>1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广</span></span><br>
        <span><span>2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.
                基本原理</span></span><br>
        <span><span>MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</span></span><br>
        <hr>

        <!-- 工作流 -->
        <h1>git flow工作流：</h1>
        <p>1.1 master分支</p>
        <span>主分支，产品的功能全部实现后，最终在master分支对外发布。</span>
        <p>1.2 develop分支</p>
        <span>开发分支，基于master分支克隆，产品的编码工作在此分支进行。</span>
        <p>1.3 release分支</p>
        <span>测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。</span>
        <p>1.4 bugfix分支</p>
        <span>Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。</span>
        <p>1.5 feature分支</p>
        <span>功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。</span>
        <hr>

        <!-- 服务器方面 -->
        <h1>服务器</h1>
        <p>错误码</p>
        <span>响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行。</span><br>
        <span>一：响应码分五种类型，由它们的第一位数字表示：</span><br>
        <span>1xx：信息，请求收到，继续处理</span><br>
        <span>2xx：成功，行为被成功地接受、理解和采纳</span><br>
        <span>3xx：重定向，为了完成请求，必须进一步执行的动作</span><br>
        <span>4xx：客户端错误，请求包含语法错误或者请求无法实现</span><br>
        <span>5xx：服务器错误，服务器不能实现一种明显无效的请求</span><br>
        <span>二：显示每个响应码及其含义：</span><br>
        <span>2xx  成功</span><br>  
        <span>200 正常;请求已完成。</span><br>  
        <span>201 正常;紧接 POST 命令。</span><br>  
        <span>202 正常;已接受用于处理，但处理尚未完成。</span><br>  
        <span>203 正常;部分信息 — 返回的信息只是一部分。</span><br>  
        <span>204 正常;无响应 — 已接收请求，但不存在要回送的信息。</span><br>     
        <hr>

        <!-- Redis缓存 -->
        <h1>Redis缓存</h1>
        <p>待总结……</p>
        <hr>

        <!-- 浏览器缓存 -->
        <h1>浏览器缓存</h1>
        <p>关于缓存的两个概念（浏览器）</p>
        <p>强缓存：</p>
        <span>用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。</span>
        <p>协商缓存：</p>
        <span>用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。</span><br>
        <span>两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。</span><br>
        <span>两者区别：从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互。</span><br>
        <p>一：静态资源的HTTP缓存</p>
        <span>1.浏览器对静态资源的HTTP缓存有两种情况，一种是强缓存(本地缓存)，另一种是弱缓存(协商缓存)。</span><br>
        <span>2.浏览器第一次请求资源时，必须下载所有的资源，然后根据响应的header内容来决定，如何缓存资源。可能采用的 是强缓存，也可能是弱缓存</span><br>
        <span>3.静态资源时的HTTP流程：</span><br>
        <span><span>3.1.强缓存阶段：先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器</span></span><br>
        <span><span>3.2.弱缓存阶段：在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。</span></span><br>
        <span><span>3.3.缓存失败阶段(重新请求)：当服务器发现该资源被修改过，或者在本地没有找到该缓存资源，服务器则返回该资源的数据。</span></span><br>
        <span>4.强缓存与弱缓存的区别：</span><br>
        <span><span>4.1.获取资源形式： 都是从缓存中获取资源的。</span></span><br>
        <span><span>4.2.状态码： 强缓存返回200(from cache),弱缓存返回304状态码<?</span><br>
        <span><span>4.3.请求(最大区别)：</span></span><br>
        <span><span><span>4.3.1.强缓存不发送请求，直接从缓存中取。</span></span></span><br>
        <span><span><span>4.3.2.弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）。</span></span></span><br>
        <span>5.强缓存：</span><br>
        <span><span>5.1强缓存是利用Expires或者Cache-Control，让原始服务器为文件设置一个过期时间，在多长时间内可以将这些内容视为最新的。</span></span><br>
        <span><span>5.2若时间未过期，则命中强缓存，使用缓存文件不发送请求。</span></span><br>
        <span>6.Cache-Control：</span><br>
        <span><span>6.1.Cache-Control是http1.1中为了弥补Expires的缺陷而加入的，当Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</span></span><br>
        <span>7.http1.0时代的缓存 Expires+Pragma</span><br>
        <span><span>★max-age=60：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 这里是60秒。</span></span><br>
        <span><span>7.1.Expires用于设置缓存到期时间：指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires，如果expires到期需要重新请求。</span></span><br>
        <span><span>★no-cache:强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。http请求没有减少会减少一个响应体(文件内容),这种个选项类似弱缓存。</span></span><br>
        <span><span>7.2.Pragma禁用缓存： Pragma:no-cache 表示防止客户端缓存，需要强制从服务器获取最新的数据；</span></span><br>
        <span>8.强缓存命中 from memory cache & from disk cache：</span><br>
        <span><span>8.1.memory cache: 将资源存到内存中，从内存中获取。</span></span><br>
        <span><span>8.2.disk cache：将资源缓存到磁盘中，从磁盘中获取。</span></span><br>
        <span>二者最大的区别在于：当退出进程时，内存中的数据会被清空，而磁盘的数据不会。</span><br>
        <span>9.ETag是一个文件的唯一标志符。</span><br>
        <p>二：在Web应用领域，Web缓存大致可以分为以下几种类型：</p>
        <p>1.数据库数据缓存</p>
        <span>Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。</span>
        <p>2.服务器端缓存：</p>
        <span>代理服务器缓存、CDN缓存</span>
        <p>3.浏览器端缓存：</p>
        <span>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</span>
        <p>4.Web应用层缓存：</p>
        <span>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</span><br>                        
        <hr>

        <!-- Nginx缓存 -->
        <h1>Nginx缓存</h1>
        <p>待总结……</p>
        <hr>

        <!-- 接口API -->
        <h1>接口API</h1>
        <p>登录</p>
        <p>第一步：签名验证</p>
        <span>1：数组（排序）并去除空值，</span><br>
        <span>2：拼接字符串  ？参数名=值&参数名=值</span><br>
        <span>3：进行MD5字符串加密</span><br>
        <span>4：MD5（第三步的结果.秘钥）得到签名字符串</span><br>
        <p>第二步：参数</p>
        <span>1：业务参数</span><br>
        <span>2：签名字符串</span><br>
        <span>3：时间戳（）在拼接字符串时验证时间戳</span><br>
        <p>第三步：数据加密</p>
        <span>1：对称加密</span><br>
        <span>2：非对称加密</span><br>
        <span>HTTPS自带数据加密</span><br>

        <!-- 优化方面 -->
        <h1>优化方面</h1>
        <p>代码优化：</p>
        <span>1、规范代码，去除没有被用到的变量声明以及引用。像这种情况，eclipse配置好以后都会出现警告标志，会指明是“never used”。这种代码的问题很容易找到，也很容易修改，因此可以让自己感觉已经开始了优化工作，只要开始了，那么这个过程中就总能发现其他需要优化的地方。</span><br>
        <span>2、规范代码，替换过时的和不推荐使用的方法。既然是过时和不被推荐的，自然有他的道理存在，除非是实在不知道怎么替换，否则我觉得都应该替换掉。这种情况和上面的情况稍有类似，也是eclipse编译的时候便会出现警告，很容易就识别出来，只不过改起来就要稍微复杂一些。 </span><br>
        <span>3、上边两个简单的优化搞定以后，我们就可以进行第三步了，注释优化。我个人认为，注释优化可以分成三种，一种是加和改，一种是减。</span><br>
        <p>说的具体明白点：</p>
        <span><span>3.1、加，就是对于那些负责具体功能和业务逻辑的类以及实体类的属性，如果没有注释我们应该加上注释，这样方便后续的维护，起码让人一眼就知道这个类、这个方法、这个属性是什么作用是什么意思。</span></span><br>
        <span><span>3.2、改，就是对于明显不合理的注释进行修改，有的时候可能整个类被复制过来改个名字，这种情况就极有可能出现注释完全不搭调的情况；当然，也有可能是看起来注释了，实际上跟没注释没什么区别的注释。</span></span><br>
        <span><span>3.3、减，就是对于那些被注释了的代码进行删除，当然了，这里我觉得也应该包括那些没有被删除的system.out.print。当然这种情况可能要根据实际情况，像我们这次遇到的完全是之前的人注释的，压根儿不知道干嘛的代码，多半是没人会再看的，我觉得就可以完全删除，省的占用空间还碍眼。</span></span><br>
        <p>很显然，在这个过程中，删的时候相对简单，如果要加或者改，那么久需要了解相关的大概逻辑，也能进一步了解项目。</p>
        <span>4、这一步可能是在上一步之后，也可能就和上一步同时进行，因为很可能就是在上一步的过程中发现的问题，就是代码逻辑上的优化。</span><br>
        <span>5、经过上一步之后，整个代码的业务逻辑按理说我们应该已经了解的差不多了，也就不至于像一开始一样那么麻头了。而实际上这时候回头看看会发现，原来不知不觉中我们已经优化了很多东西了。那么这时候就可以进行一个对于性能来说至关重要的优化，但是相对来说也不太容易实施的步骤，那就是数据库优化。</span><br>
        <p>这里的数据库优化我觉得也可以分为两步：一个是sql语句的优化，一个就是表结构、索引相关的优化。</p>
        <hr>
        <h1>Git更新|提交</h1>
        <img src="./git_提交更新.png" alt="暂无">

        <!-- PHP知识 -->
        <h1>PHP零碎知识</h1>
        <span>1、PHP的isset()函数 一般用来检测变量是否设置。</span><br>
        <span>2、PHP的empty()函数 判断值为否为空。</span><br>
        <hr>
        <h1>php魔术方法</h1>
        <p>1.__construct，__destruct</p>
        <span>__constuct构建对象的时被调用；</span><br>
        <span>__destruct明确销毁对象或脚本结束时被调用；</span><br>
        <p>2.__get，__set</p>
        <span>__set当给不可访问或不存在属性赋值时被调用</span><br>
        <span>__get读取不可访问或不存在属性时被调用</span><br>
        <p>3.__isset，__unset</p>
        <span>__isset对不可访问或不存在的属性调用isset()或empty()时被调用</span><br>
        <span>__unset对不可访问或不存在的属性进行unset时被调用</span><br>
        <p>4.__call，__callStatic</p>
        <span>__call调用不可访问或不存在的方法时被调用</span><br>        
        <span>__callStatic调用不可访问或不存在的静态方法时被调用</span><br>        
        <p>5.__sleep，__wakeup</p>
        <span>__sleep当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用</span><br>
        <span>__wakeup当使用unserialize时被调用，可用于做些对象的初始化操作</span><br>
        <p>6.__clone</p>
        <span>进行对象clone时被调用，用来调整对象的克隆行为</span>
        <p>7.__toString</p>
        <span>当一个类被转换成字符串时被调用</span>
        <p>8.__invoke</p>
        <span>当以函数方式调用对象时被调用</span>
        <p>9.__set_state</p>
        <span>当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。</span>
        <p>10.__debuginfo</p>
        <span>当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本</span>

        <!-- SQL语句相关 -->
        <h1>SQL语句</h1>
        <p>sql语句执行顺序</p>
        <span>(1)from </span><br>
        <span>(3) join </span><br>
        <span>(2) on </span><br>
        <span>(4) where </span><br>
        <span>(5)group by(开始使用select中的别名，后面的语句中都可以使用) </span><br>
        <span>(6) avg,sum.... </span><br>
        <span>(7)having </span><br>
        <span>(8) select </span><br>
        <span>(9) distinct </span><br>
        <span>(10) order by </span><br>
        <hr>

        <!-- 配置lnmp环境 -->
        <h1>配置lnmp环境</h1>
        <p>NGINX</p>
        <span>https://github.com/josneps/root/blob/master/Nginx.txt</span>
        <p>PHP</p>
        <span>https://github.com/josneps/root/blob/master/PHP.txt</span>
        <p>MySQL</p>
        <span>http://www.cnblogs.com/luohanguo/p/9045391.html</span>
    </div>
</body>
</html>